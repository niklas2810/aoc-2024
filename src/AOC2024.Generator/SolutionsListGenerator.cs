using System.Collections.Generic;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace AOC2024.Generator
{

    /// <summary>
    /// Generates a list of all implementations of the DayBase class.
    /// </summary>
	[Generator]
    public class SolutionsListGenerator : ISourceGenerator
    {

        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new ClassSyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {

			var dayBaseType = context.Compilation.GetTypeByMetadataName("AOC2024.Cli.Solutions.DayBase");
            if (dayBaseType == null)
            {
				var diagnostic = Diagnostic.Create(new DiagnosticDescriptor(
			        id: "DBSG001",
			        title: "DayBase Type Not Found",
			        messageFormat: "The type 'AOC2024.Cli.Solutions.DayBase' could not be found.",
			        category: "DayBaseSourceGenerator",
			        DiagnosticSeverity.Error,
			        isEnabledByDefault: true),
			        Location.None);

				context.ReportDiagnostic(diagnostic);
                return;
            }

            var implementations = new List<string>();

            if(context.SyntaxReceiver is not ClassSyntaxReceiver receiver)
                return;

            foreach (var classDeclaration in receiver.Classes)
            {
                var model = context.Compilation.GetSemanticModel(classDeclaration.SyntaxTree);

                if (model.GetDeclaredSymbol(classDeclaration) is INamedTypeSymbol symbol && symbol.BaseType.Equals(dayBaseType, SymbolEqualityComparer.Default))
                {
                    implementations.Add(symbol.ToString());
                }
            }

            /*foreach (var st in context.Compilation.SyntaxTrees
                .Where(tree => tree.GetRoot().DescendantNodes()
                .OfType<ClassDeclarationSyntax>()
                .Any()))
            {
                var model = context.Compilation.GetSemanticModel(st);
                foreach (var classDeclaration in st.GetRoot().DescendantNodes().OfType<ClassDeclarationSyntax>())
                {
                    var symbol = model.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol;
                    if (symbol != null && symbol.BaseType.Equals(dayBaseType, SymbolEqualityComparer.Default))
                    {
                        Debug.WriteLine($"dbsg: Found implementation: {symbol}");
                        implementations.Add(symbol.ToString());
                    }
                }
            }*/

				var sourceBuilder = new StringBuilder(@"
/// <summary>
/// This file has been generated by the SolutionsListGenerator.
/// </summary>
using AOC2024.Cli.Solutions;
using System.Collections.Generic;

namespace AOC2024.Cli.Utils
{
    public static class ImplementedSolutions
    {
        public static readonly IEnumerable<DayBase> All = new List<DayBase>
        {
");

            foreach (var implementation in implementations)
            {
                sourceBuilder.AppendLine($"            new {implementation}(),");
            }

            sourceBuilder.Append(@"
        };
    }
}
");
            context.AddSource("ImplementedSolutions.g.cs", SourceText.From(sourceBuilder.ToString(), Encoding.UTF8));
        }

        private class ClassSyntaxReceiver : ISyntaxReceiver
        {
            public List<ClassDeclarationSyntax> Classes { get; } = new List<ClassDeclarationSyntax>();

            public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
            {
                if (syntaxNode is ClassDeclarationSyntax classDeclarationSyntax)
                {
                    if(classDeclarationSyntax.BaseList?.Types.Count > 0 )
                        Classes.Add(classDeclarationSyntax);
                }
            }
        }
    }
}
